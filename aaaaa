#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h> //usado no system('cls')

#define MAX_ALUNOS 30
#define NUM_AULAS 36
int n_alunos = 1;
int n_atualAlunos = 0;
int matriculas[MAX_ALUNOS];
int faltas[MAX_ALUNOS];
float notas[MAX_ALUNOS][4];

float alunos[MAX_ALUNOS][6]; // matriz que armazenara todos os dados de uma vez

// estrutura para armazenar informa√ß√µes do aluno
struct Aluno {
  int matricula;
  float notas[4];
  int faltas;
};

struct Aluno matriculasT[MAX_ALUNOS];  // cria um vetor do tipo Aluno que vai conter todos os parametros presente na struct Aluno.

/* como a fun√ß√£o cadastrarAluno √© do tipo void, ela nao precisa de um retorno
 (return). nessafun√ß√£o ela n√£o estava armazenando as matriculas passadas dentro
 do vetor matriculas. Foi criado uma variavel de controle e arrumar a valida√ß√£o
 da inclus√£o e matricula.
*/

void cadastrarAluno(void) {
  if (n_alunos >= MAX_ALUNOS) {
    printf("Erro: nao e possivel cadastrar mais alunos.\n");
  } else {

    int matricula;
    int controlador; // variavel que fara o controle do numero de alunos
                     // cadastrados.

    // esse for mais externo √© respons√°vel por armazenar na posi√ß√£o correta as
    // matriculas seguindo a ordem em que foram passadas
    for (int i = n_atualAlunos; i < n_alunos; i++) {

      printf("Digite a matricula do aluno: ");
      scanf("%d", &matricula);

      // esse for mais interno √© respons√°vel por verificar se uma determinada
      // matricula ja foi cadastrada.
      for (int k = 0; k < n_alunos; k++) {

        // verifica se a matricula ja foi cadastrada
        if (matriculas[k] != -1) {
          if (matriculas[k] == matricula) {
            printf("\nMatricula ja cadastrada.\n");
            controlador = 0;
            break;
          }
        } else {
          // caso a matricula n√£o tenha sido cadastrada, ela √© armazenada na
          // posi√ß√£o correta. e o controlador recebe 1 indicando que foi feito o
          // cadastro.
          matriculas[i] = matricula;
          controlador = 1;
          printf("\nüéÜüéáüéáüéÜmatricula cadastrada com sucessoüéÜüéáüéáüéÜ\n");
        }
      }
    }
    // com o cadastro sendo feito o n_AtualAluno √© acrescido de mais 1 assim
    // como o n_Alunos que no caso √© a quantidade total de alunos cadastrados
    if (controlador == 1) {
      n_atualAlunos++;
      n_alunos++;
    }
  }
}

/*

pelo que vi dessas fun√ß√µes abaixo voc√™ n√£o esta declarando nenhuma fun√ß√£o, pois
as fun√ß√µes s√£o declaradas da seguinte forma: -tipo da fun√ß√£o- NomeDaFun√ß√£o
(parametros (caso n√£o exista parametros, basta escrever void)){
       --- comandos da fun√ß√£o ---
        }
        recomendo voc√™ revisar como se controi uma fun√ß√£o em C, para poder fazer
todas funcionarem corretamente.
*/

// Fun√ß√£o para remover um aluno
void removerAluno(void) {
  if (n_alunos == 0) {
    printf("Erro: nenhum aluno cadastrado.\n");
  }

  int matricula;
  printf("Digite a matricula do aluno a ser removido: ");
  scanf("%d", &matricula);

  int index = -1;
  for (int i = 0; i < n_alunos; i++) {
    if (matriculas[i] == matricula) {
      index = i;
      break;
    }
  }
  if (index == -1) {
    printf("Erro: matricula nao encontrada.\n");
    return;
  }

  // Remover o aluno e reorganizar o vetor
  for (int i = index; i < n_alunos - 1; i++) {
    matriculas[i] = matriculas[i + 1];
    faltas[i] = faltas[i + 1];
    for (int j = 0; j < 4; j++) {
      notas[i][j] = notas[i + 1][j];
    }
  }
  n_alunos--;
  printf("O Aluno com a matricula: %d foi removido com sucesso.\n", matricula);
}

// Fun√ß√£o para atualizar os dados de um aluno
/*
 * nessa fun√ß√£o voc√™ queria usar o struct que voc√™ criou dentro de um vetor, contudo da forma como seu codigo vem sendo escrito isso n√£o vai funcionar aqui
 * pq n√£o haver√° rela√ß√£o entre as estruturas. Por isso nesse caso aqui o recomendado √© voc√™ utilizar os vetores notas e falta que voc√™ criou, porem creio que o
 * melhor √© voc√™ criar uma matriz unica que vai armazenar todos os dados (no caso eu criei a matriz alunos), ent√£o e voc√™ obtar por esse metodo voc√™ tera que 
 * modificar todas as demias fun√ß√µes anteriores, porem creio eu que ficar√° mais facil. Assim sendo, vou modificar essa fun√ß√£o de modo que ela utilize a matriz
 * alunos. Assim como na fun√ß√£o cadastrar a matriz tera que ser inicializada para que funcione de maneira correta. Esse metodo tambem vai reduzir bastante o 
 * uso dos verores e diminuir o uso de memoria.
*/
  void atualizarDados(void) {
    if(n_alunos == 1){
      printf("\n‚ùå‚ùåN√£o existem alunos cadastrados‚ùå‚ùå\n");
      return;
    }
      
    int i, encontrado = 0, contador=0;
	float matricula, faltas; // como a matriz alunos √© do tipo float, ela s√≥ vai aceitar a entrada de dados que tambem sejam do tipo float.
	
    printf("\nDigite a matricula do aluno: ");
    scanf("%f", &matricula);
    
    for ( i = 0; i < n_atualAlunos; i++) {
       if (matricula == matriculas[i]) {
            encontrado = 1;
            alunos[i][0] = matricula; // a primeira linha da matriz e a primeira coluna recebe a matricula do aluno encontrado,
            printf("\nDigite as notas do aluno (4 notas):\n");
            scanf("%f %f %f %f", &alunos[i][1],&alunos[i][2], &alunos[i][3], &alunos[i][4]); //as notas do aluno s√£o colocadas na ordem, mas na mesma linha dentro da matriz
            printf("\nDigite o numero de faltas do aluno: ");
            scanf("%f", &alunos[i][5]); // as faltas do aluno s√£o armazenadas na ultima posic√£o da mesma linha em que a matricula foi inserida.
            printf("\nDados do aluno atualizados com sucesso.");
            break;
        
    }

      


}
        if (encontrado==0) {
        printf("\n‚ùå‚ùåAluno nao encontrado ou n√£o exite.‚ùå‚ùå");
        printf("%d aaaaaa", encontrado);
    }
    }
/*
 * bem pela analise do seu codigo, eu notei que voc√™ esta tentando usar o struct Aluno que voc√™ criou dentro de um vetor, isso √© uma ideia muito boa
 * pq vai "reduzir" a quantidade de vetores do seu codigo e logo vai "diminuir" o uso da memoria. contudo se voc√™ fizer desse jeito tera que modificar todas
 * as demais fun√ß√µes do seu codigo. Primeiro foi necessario declarar o vetor do tipo Aluno, conforme fiz la em cima. e da mesma o vetor matriculasT tera que ser 
 * inicializado. 
*/
/*
  void atualizarDados(void) {
    if(n_alunos == 0){
      printf("N√£o existem alunos cadastrados");
    }
    int matricula, faltas,
  
    printf("\nDigite a matricula do aluno: ");
    scanf("%d", &matricula);
    
    for (int i = 0; i < n_atualAlunos; i++) {
       if (matricula == n_alunos.matricula[i]) {
            encontrado = 1;
            matriculasT[i].matricula = matricula; // sera armazenado no vetor matriculasT na posi√ß√£o i no parametro matricula a matricula informada
            // matriculasT[i]->matricula = matricula;
            
             //esse for abaixo ira armazenar dentro do vetor notas definido no struct Aluno cada nota passada na ordem correta
            for(int j = 0; j < 4; j++){
				printf("Digite a %d nota: ", i+1);
				scanf("%f", &matriculasT[i]->notas[j]); 
			}
            printf("\nDigite o numero de faltas do aluno: ");
            scanf("%d", &matriculasT[i]->faltas); // armazena as faltas do aluno dentro do parametro faltas do struct Aluno
            printf("\nDados do aluno atualizados com sucesso.");
            break;
        }
    
    if (!encontrado) {
        printf("\nAluno nao encontrado ou n√£o exite.");
    }
}
*/




void listarAlunos(void) {
  if (n_alunos == 1) {
    printf("N√£o existe cadastrados");
    return;
  }
  // se tiver alkunos fa√ßa
  for (int i = 0; i < n_atualAlunos; i++) {
    printf("Matricula: %d | Numero de faltas: %.0f | Suas notas respectivamente: %.2f %.2f %.2f %.2f", matriculas[i], alunos[i][5], alunos[i][1], alunos[i][2], alunos[i][3], alunos[i][4] );

  }
}

/*
  void listarAprovados(void){
    float media, soma;
    int i,j;
    for (i=0 ; i< 4 ; i++){
      soma = soma+alunos[i].notas[j];
    }
    media = soma/4;
  }
*/

/* Fun√ß√£o para exibir o menu de op√ß√µes
Fiz umas pequenas modifica√ß√µes na sua fun√ß√£o exibirMenu fazendo o switch case
funcionar corretamente, com o uso do comando break dentro de um la√ßo que s√≥ √©
interrompido quando se digita a opcao 8. Para que n√£o haja conflito na
convoca√ß√£o de uma determinada fun√ß√£o, sempre recomendo que se declare as fun√ß√µes
a cima de onde elas s√£o convocadas nesse caso como a fun√ß√£o exibirMenu vai
funcionar como o gerenciador das demais fun√ß√µes, todas as outras fun√ß√µes que ela
for utilizar devem ser criadas acima dela, conforme eu organizei aqui.
*/
void exibirMenu(void) {
  int opcao;
  do {
    printf("\nSelecione uma opcao:\n");
    printf("1 - Cadastrar aluno\n");
    printf("2 - Remover aluno\n");
    printf("3 - Atualizar dados de um aluno\n");
    printf("4 - Listar alunos cadastrados\n");
    printf("5 - Listar alunos aprovados\n");
    printf("6 - Listar alunos reprovados por media\n");
    printf("7 - Listar alunos reprovados por faltas\n");
    printf("8 - Sair\n");
    printf("\n\nDigite alguma op√ß√£o: \n");
    scanf("%d", &opcao);
    system("clear");
    switch (opcao) {
    case 1:
      cadastrarAluno();
      break;
    case 2:
      removerAluno();
      break;
    case 3:
       atualizarDados();
      break;
    case 4:
      listarAlunos();
      break;
    case 5:
      // listaraprovados();
      break;
    case 6:
      // listarreprovmedia();
      break;
    case 7:
      // listarReprovadosPorFaltas();
      break;
    case 8:
      printf("Voc√™ escolheu sair!");
      break;
    default:
      printf("Op√ß√£o n√£o existe, digite outra!");
      break;
    }
  } while (opcao != 8);
}

// a fun√ß√£o principal que no caso √© o main vai funcionar apenas por meio da
// fun√ß√£o exibirMenu que faz a convoca√ß√£o das demais fun√ß√µes necessarias. o main
// sempre deve ser a ultima fun√ß√£o do programa.
int main() {

  // Esse for faz a inicializa√ß√£o do vetor matriculas, pois assim √© um jeito
  // mais facil de percorrer o vetor e fazer as alteracoes dentro do proprio
  // vetor, pois antes a matricula passada sempre era armazenada na primeira
  // posi√ß√£o e as demais ficavam vazias. e como n√£o sabemos quantos alunos ser√£o
  // armazenados, √© melhor inicializar o vetor por completo.
  for (int j = 0; j < MAX_ALUNOS; j++) {
    matriculas[j] = -1;
  }

  exibirMenu();

  // esse for n√£o √© necessario, mas ele faz tipo um debug, ele mostra os valores
  // que foram cadatrados dentro do vetor matriculas
  for (int j = 0; j < n_alunos; j++) {

    // como todo o vetor foi inicializado com -1 para nao ter problemas visual
    // de exibir -1, esse if os exclui.
    if (matriculas[j] != -1) {
      printf("%d\n", matriculas[j]);
    }
  }
  
  
  
/*
 * esses dois for motram como ira funcionar o processo de leitura e armazenamento dos dados passados e a exibi√ß√£o desses dados no vetor matriculasT que √© do 
 * tipo Aluno, n√£o se difere dos demais metodos porem ao inves de usar um ponto para indicar o local a ser guardado(matriculasT[posi√ß√£o].matricula) √© utilizado 
 * uma setinha (->) para indicar o local a ser armazenado (matriculasT[posi√ß√£o]->matricula). porem na hora da exibi√ß√£o usa-se o ponto conforme √© mostrado abaixo.
 * 
*/
  // armazena os dados no vetor
  for(int a = 0; a < 5; a++){
		printf("Informe a matricula do aluno: \n");
		scanf("%d", &matriculasT -> matricula);
		for(int b = 0; b < 4; b++){
			printf("Informe a %d nota: ", b+1);
			scanf("%f", &matriculasT -> notas[b]);
		}
		printf("Digite a quantidade de faltas: \n");
		scanf("%d", &matriculasT -> faltas);
	}
	
	// exibe os dados do vetor
	for(int c = 0; c < 5; c++){
		printf("matricula: %d", matriculasT[c].matricula);
		printf("Notas: ");
		for(int d = 0; d < n_alunos; d++){
			printf("%.0f", matriculasT[c].notas[d]);
		}
		printf("faltas: %d", matriculasT[c].faltas);
	}
  return 0;
}
    



